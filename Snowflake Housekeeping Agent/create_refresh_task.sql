-- Create automated task for daily query history refresh
-- Run this AFTER initial materialization is complete

USE DATABASE PLATFORM_ANALYTICS;
USE SCHEMA PUBLIC;

-- Create stored procedure for the refresh logic
CREATE OR REPLACE PROCEDURE REFRESH_QUERY_HISTORY_PROC()
RETURNS STRING
LANGUAGE SQL
AS
$$
BEGIN
-- Incremental insert of new queries
INSERT INTO QUERY_HISTORY_MATERIALIZED
SELECT 
    -- Core Query Identification
    QUERY_ID, QUERY_TEXT, QUERY_TYPE, QUERY_HASH, QUERY_PARAMETERIZED_HASH, QUERY_TAG,
    
    -- User & Security Context
    USER_NAME, ROLE_NAME, USER_TYPE,
    
    -- Infrastructure Context  
    DATABASE_NAME, SCHEMA_NAME, WAREHOUSE_NAME, WAREHOUSE_SIZE, WAREHOUSE_TYPE,
    
    -- Execution Context
    START_TIME, END_TIME, TOTAL_ELAPSED_TIME, EXECUTION_TIME, COMPILATION_TIME,
    EXECUTION_STATUS, ERROR_CODE, ERROR_MESSAGE,
    
    -- Performance Metrics
    BYTES_SCANNED, BYTES_WRITTEN, BYTES_DELETED, ROWS_PRODUCED, ROWS_INSERTED,
    ROWS_UPDATED, ROWS_DELETED, ROWS_UNLOADED, PERCENTAGE_SCANNED_FROM_CACHE,
    
    -- Cost Metrics
    CREDITS_USED_CLOUD_SERVICES,
    
    -- Data Transfer
    INBOUND_DATA_TRANSFER_BYTES, OUTBOUND_DATA_TRANSFER_BYTES,
    INBOUND_DATA_TRANSFER_CLOUD, INBOUND_DATA_TRANSFER_REGION,
    OUTBOUND_DATA_TRANSFER_CLOUD, OUTBOUND_DATA_TRANSFER_REGION,
    
    -- Memory & Spill
    BYTES_SPILLED_TO_LOCAL_STORAGE, BYTES_SPILLED_TO_REMOTE_STORAGE,
    BYTES_READ_FROM_RESULT, BYTES_SENT_OVER_THE_NETWORK, BYTES_WRITTEN_TO_RESULT,
    
    -- Advanced Metrics
    PARTITIONS_SCANNED, PARTITIONS_TOTAL, QUERY_LOAD_PERCENT, CLUSTER_NUMBER,
    
    -- Queue & Wait Times
    QUEUED_OVERLOAD_TIME, QUEUED_PROVISIONING_TIME, QUEUED_REPAIR_TIME, CHILD_QUERIES_WAIT_TIME,
    
    -- System Context
    SESSION_ID, TRANSACTION_ID, TRANSACTION_BLOCKED_TIME, RELEASE_VERSION,
    
    -- External Functions
    EXTERNAL_FUNCTION_TOTAL_INVOCATIONS, EXTERNAL_FUNCTION_TOTAL_SENT_ROWS,
    EXTERNAL_FUNCTION_TOTAL_RECEIVED_ROWS, EXTERNAL_FUNCTION_TOTAL_SENT_BYTES,
    EXTERNAL_FUNCTION_TOTAL_RECEIVED_BYTES,
    
    -- Additional Context
    IS_CLIENT_GENERATED_STATEMENT, QUERY_RETRY_CAUSE, QUERY_RETRY_TIME,
    FAULT_HANDLING_TIME, LIST_EXTERNAL_FILES_TIME,
    
    -- Derived Searchable Fields
    CONCAT_WS(' | ',
        COALESCE(QUERY_TYPE, 'UNKNOWN'),
        COALESCE(DATABASE_NAME, 'NO_DB'),
        COALESCE(SCHEMA_NAME, 'NO_SCHEMA'),
        COALESCE(USER_NAME, 'NO_USER'),
        COALESCE(ROLE_NAME, 'NO_ROLE'),
        COALESCE(WAREHOUSE_NAME, 'NO_WAREHOUSE'),
        CASE WHEN ERROR_CODE IS NOT NULL THEN 'ERROR' ELSE 'SUCCESS' END,
        CASE 
            WHEN TOTAL_ELAPSED_TIME > 300000 THEN 'LONG_RUNNING'
            WHEN TOTAL_ELAPSED_TIME > 30000 THEN 'MEDIUM_DURATION'
            ELSE 'QUICK'
        END,
        CASE
            WHEN CREDITS_USED_CLOUD_SERVICES > 0.1 THEN 'HIGH_COST'
            WHEN CREDITS_USED_CLOUD_SERVICES > 0.01 THEN 'MEDIUM_COST'
            WHEN CREDITS_USED_CLOUD_SERVICES > 0 THEN 'LOW_COST'
            ELSE 'MINIMAL_COST'
        END
    ) AS SEARCH_METADATA,
    
    -- Human-readable query summary
    CONCAT(
        'Query Type: ', COALESCE(QUERY_TYPE, 'Unknown'), ' | ',
        'User: ', COALESCE(USER_NAME, 'Unknown'), ' | ',
        'Role: ', COALESCE(ROLE_NAME, 'Unknown'), ' | ',
        'Database: ', COALESCE(DATABASE_NAME, 'None'), ' | ',
        'Warehouse: ', COALESCE(WAREHOUSE_NAME, 'None'), ' | ',
        'Duration: ', COALESCE(ROUND(TOTAL_ELAPSED_TIME/1000, 2), 0), ' seconds | ',
        'Status: ', COALESCE(EXECUTION_STATUS, 'Unknown'), ' | ',
        'Data Scanned: ', COALESCE(ROUND(BYTES_SCANNED/POWER(1024,3), 2), 0), ' GB | ',
        'Credits: ', COALESCE(ROUND(CREDITS_USED_CLOUD_SERVICES, 4), 0)
    ) AS QUERY_SUMMARY,
    
    -- Performance categorization
    CASE 
        WHEN TOTAL_ELAPSED_TIME > 300000 THEN 'LONG_RUNNING'
        WHEN TOTAL_ELAPSED_TIME > 30000 THEN 'MEDIUM_DURATION'
        WHEN TOTAL_ELAPSED_TIME > 5000 THEN 'QUICK'
        ELSE 'INSTANT'
    END AS PERFORMANCE_CATEGORY,
    
    -- Cost categorization
    CASE
        WHEN CREDITS_USED_CLOUD_SERVICES > 1.0 THEN 'VERY_EXPENSIVE'
        WHEN CREDITS_USED_CLOUD_SERVICES > 0.1 THEN 'EXPENSIVE'
        WHEN CREDITS_USED_CLOUD_SERVICES > 0.01 THEN 'MODERATE'
        WHEN CREDITS_USED_CLOUD_SERVICES > 0 THEN 'LOW_COST'
        ELSE 'FREE'
    END AS COST_CATEGORY,
    
    -- Materialization timestamp (FIXED FORMAT)
    CURRENT_TIMESTAMP() AS MATERIALIZED_AT

FROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY qh
WHERE qh.START_TIME > (
    SELECT COALESCE(MAX(START_TIME), CURRENT_DATE - INTERVAL '60 DAYS')
    FROM QUERY_HISTORY_MATERIALIZED
)
AND qh.START_TIME < CURRENT_DATE
AND NOT EXISTS (
    SELECT 1 
    FROM QUERY_HISTORY_MATERIALIZED qhm 
    WHERE qhm.QUERY_ID = qh.QUERY_ID
);

-- Clean up old data (keep rolling 60-day window)
DELETE FROM QUERY_HISTORY_MATERIALIZED
WHERE START_TIME < CURRENT_DATE - INTERVAL '60 DAYS';

RETURN 'Query history refresh completed successfully';
END;
$$;

-- Create the task to run daily at 2 AM
CREATE OR REPLACE TASK REFRESH_QUERY_HISTORY_TASK
  WAREHOUSE = COMPUTE_WH  -- Replace with your warehouse
  SCHEDULE = 'USING CRON 0 2 * * * UTC'  -- Daily at 2 AM UTC
  COMMENT = 'Daily refresh of materialized query history for search service'
AS
CALL REFRESH_QUERY_HISTORY_PROC();

-- Start the task
ALTER TASK REFRESH_QUERY_HISTORY_TASK RESUME;

-- Grant permissions
GRANT USAGE ON PROCEDURE REFRESH_QUERY_HISTORY_PROC() TO ROLE SYSADMIN;
GRANT EXECUTE ON TASK REFRESH_QUERY_HISTORY_TASK TO ROLE SYSADMIN;

-- Check procedure and task status
SHOW PROCEDURES LIKE 'REFRESH_QUERY_HISTORY_PROC';
SHOW TASKS LIKE 'REFRESH_QUERY_HISTORY_TASK';

-- =============================================================================
-- MANUAL REFRESH COMMANDS
-- =============================================================================

-- Manual task execution (run this to test the task immediately)
EXECUTE TASK REFRESH_QUERY_HISTORY_TASK;

-- OR manually run the procedure directly (faster for testing)
CALL REFRESH_QUERY_HISTORY_PROC();

-- Manual search service refresh (run after task completes)
ALTER CORTEX SEARCH SERVICE QUERY_HISTORY_SEARCH_SERVICE REFRESH;

-- Check task execution history
SELECT 
    NAME,
    STATE,
    SCHEDULED_TIME,
    COMPLETED_TIME,
    ERROR_CODE,
    ERROR_MESSAGE
FROM TABLE(INFORMATION_SCHEMA.TASK_HISTORY(
    TASK_NAME => 'REFRESH_QUERY_HISTORY_TASK',
    SCHEDULED_TIME_RANGE_START => DATEADD('hour', -1, CURRENT_TIMESTAMP())
))
ORDER BY SCHEDULED_TIME DESC
LIMIT 5;

-- Verify data was refreshed
SELECT 
    'MANUAL REFRESH VERIFICATION' AS status,
    COUNT(*) AS total_queries,
    MIN(START_TIME) AS earliest_query,
    MAX(START_TIME) AS latest_query,
    COUNT(DISTINCT USER_NAME) AS unique_users,
    MAX(MATERIALIZED_AT) AS latest_materialization,
    COUNT(CASE WHEN MATERIALIZED_AT >= CURRENT_DATE THEN 1 END) AS records_added_today
FROM QUERY_HISTORY_MATERIALIZED;
